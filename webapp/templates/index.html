<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Weather & Wikipedia</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 30px;
        }
        
        .search-box {
            display: flex;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .search-box input {
            flex: 1;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .search-box button {
            padding: 15px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
        }
        
        .search-box button:hover {
            background: #5568d3;
        }
        
        .status {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .weather-card {
            width: 100%;
        }
        
        .wikipedia-card {
            width: 100%;
        }
        
        .card h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .weather-hours {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .weather-hour {
            background: #f8f9fa;
            padding: 18px;
            border-radius: 8px;
            margin-bottom: 12px;
            display: grid;
            grid-template-columns: 100px 120px 1fr;
            gap: 20px;
            align-items: center;
            transition: all 0.2s ease;
            border: 1px solid #e0e0e0;
        }
        
        .weather-hour:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .weather-hour.today {
            /* Match future days styling - no special blue background */
            background: #f8f9fa;
            border-left: 1px solid #e0e0e0;
        }
        
        .hour-time {
            font-weight: bold;
            color: #333;
            font-size: 0.95em;
        }
        
        .hour-time.today {
            color: #333; /* Match regular hour time color */
        }
        
        .hour-temp {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .hour-main-details {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .hour-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px;
            font-size: 0.85em;
        }
        
        .hour-detail {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: white;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .hour-detail-icon {
            font-size: 1.1em;
        }
        
        .hour-detail-label {
            color: #666;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hour-detail-value {
            color: #333;
            font-weight: 600;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
        }
        
        .wikipedia-content {
            line-height: 1.8;
            color: #333;
        }
        
        .wikipedia-content h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .wikipedia-content p {
            margin-bottom: 15px;
        }
        
        .wikipedia-content a {
            color: #667eea;
            text-decoration: none;
        }
        
        .wikipedia-content a:hover {
            text-decoration: underline;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        .suggestions-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 5px;
        }
        
        .suggestion-item {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }
        
        .suggestion-item:hover {
            background: #f8f9fa;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item .suggestion-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
        }
        
        .suggestion-item .suggestion-details {
            font-size: 0.85em;
            color: #666;
        }
        
        body.dark-mode .suggestions-dropdown {
            background: #2d2d44;
            border-color: #444;
        }
        
        body.dark-mode .suggestion-item {
            border-bottom-color: #444;
        }
        
        body.dark-mode .suggestion-item:hover {
            background: #1a1a2e;
        }
        
        body.dark-mode .suggestion-item .suggestion-name {
            color: #e0e0e0;
        }
        
        body.dark-mode .suggestion-item .suggestion-details {
            color: #b0b0b0;
        }
        
        /* Dark mode styles */
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        body.dark-mode header,
        body.dark-mode .card {
            background: #2d2d44;
            color: #e0e0e0;
        }
        
        body.dark-mode h1,
        body.dark-mode h2,
        body.dark-mode h3 {
            color: #e0e0e0;
        }
        
        body.dark-mode .subtitle {
            color: #b0b0b0;
        }
        
        body.dark-mode input {
            background: #1a1a2e;
            color: #e0e0e0;
            border-color: #444;
        }
        
        body.dark-mode input:focus {
            border-color: #667eea;
        }
        
        body.dark-mode .weather-hour {
            background: #1a1a2e;
            color: #e0e0e0;
        }
        
        body.dark-mode .weather-hour.today {
            /* Match future days styling in dark mode */
            background: #1a1a2e;
            border-left-color: #333;
        }
        
        body.dark-mode .hour-time {
            color: #e0e0e0;
        }
        
        body.dark-mode .hour-time.today {
            color: #e0e0e0; /* Match regular hour time color in dark mode */
        }
        
        body.dark-mode .hour-temp {
            color: #667eea;
        }
        
        body.dark-mode .hour-detail {
            color: #b0b0b0;
            background: #1a1a2e;
        }
        
        body.dark-mode .hour-detail-label {
            color: #888;
        }
        
        body.dark-mode .hour-detail-value {
            color: #e0e0e0;
        }
        
        body.dark-mode .weather-hour {
            background: #1a1a2e;
            border-color: #333;
        }
        
        body.dark-mode .weather-hour:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        body.dark-mode .current-weather-card {
            background: linear-gradient(135deg, #2a3a5e 0%, #1a1a2e 100%);
        }
        
        body.dark-mode .wikipedia-content {
            color: #e0e0e0;
        }
        
        body.dark-mode .wikipedia-content h3 {
            color: #e0e0e0;
        }
        
        body.dark-mode .wikipedia-content p {
            color: #d0d0d0;
        }
        
        body.dark-mode .wikipedia-description {
            color: #a0c4ff !important;
        }
        
        body.dark-mode .wikipedia-link {
            background: #667eea;
            color: white;
        }
        
        body.dark-mode .wikipedia-link:hover {
            background: #5568d3;
        }
        
        body.dark-mode .wikipedia-divider {
            border-top-color: #444 !important;
        }
        
        body.dark-mode .status.success {
            background: #1e4d2e;
            color: #90ee90;
        }
        
        body.dark-mode .status.error {
            background: #4d1e1e;
            color: #ff6b6b;
        }
        
        body.dark-mode .status.loading {
            background: #1e3a4d;
            color: #87ceeb;
        }
        
        body.dark-mode .error {
            background: #4d1e1e;
            color: #ff6b6b;
        }
        
        body.dark-mode .loading {
            color: #b0b0b0;
        }
        
        body.dark-mode .empty-state {
            color: #b0b0b0;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: flex-end;
        }
        
        .control-button {
            padding: 8px 16px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        
        .control-button:hover {
            background: #e0e0e0;
        }
        
        body.dark-mode .control-button {
            background: #1a1a2e;
            border-color: #444;
            color: #e0e0e0;
        }
        
        body.dark-mode .control-button:hover {
            background: #2a2a3e;
        }
        
        .control-button.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h1>üåç City Weather & Wikipedia</h1>
                    <p class="subtitle">Search for any city to see 7-day weather forecast and Wikipedia article</p>
                </div>
                <div class="controls">
                    <button class="control-button" id="unitToggle" onclick="toggleUnitSystem()">Imperial / Metric</button>
                    <button class="control-button" id="darkModeToggle" onclick="toggleDarkMode()">üåô Dark</button>
                </div>
            </div>
            
            <form class="search-box" id="searchForm">
                <div style="position: relative; flex: 1;">
                    <input type="text" id="cityInput" placeholder="Enter city name (e.g., Boston, Paris, Tokyo)" required autocomplete="off">
                    <div id="citySuggestions" class="suggestions-dropdown" style="display: none;"></div>
                </div>
                <input type="text" id="countryInput" placeholder="Country (optional)" style="width: 200px;" autocomplete="off">
                <button type="submit">üîç Search</button>
            </form>
            
            <div id="status" class="status" style="display: none;"></div>
        </header>
        
        <div class="content" id="content" style="display: none;">
            <div class="card weather-card">
                <h2>üå§Ô∏è Hourly Weather Forecast</h2>
                <div id="weatherContent">
                    <div class="loading">Loading weather data...</div>
                </div>
            </div>
            
            <div class="card wikipedia-card">
                <h2>üìö Wikipedia Article</h2>
                <div id="wikipediaContent">
                    <div class="loading">Loading Wikipedia article...</div>
                </div>
            </div>
        </div>
        
        <div id="emptyState" class="card empty-state">
            <div class="empty-state-icon">üåé</div>
            <h2>Search for a City</h2>
            <p>Enter a city name above to see its 7-day weather forecast and Wikipedia article</p>
        </div>
    </div>
    
    <script>
        let weatherChart = null;
        let useImperial = false;
        let darkMode = false;
        
        // Unit conversion functions
        function celsiusToFahrenheit(celsius) {
            return (celsius * 9/5) + 32;
        }
        
        function metersPerSecondToMph(mps) {
            return mps * 2.237;
        }
        
        function millimetersToInches(mm) {
            return mm * 0.0393701;
        }
        
        function formatTemperature(celsius) {
            if (celsius === null || celsius === undefined) return 'N/A';
            const temp = useImperial ? celsiusToFahrenheit(celsius) : celsius;
            const unit = useImperial ? '¬∞F' : '¬∞C';
            return temp.toFixed(1) + unit;
        }
        
        function formatWindSpeed(mps) {
            if (mps === null || mps === undefined) return 'N/A';
            const speed = useImperial ? metersPerSecondToMph(mps) : mps;
            const unit = useImperial ? 'mph' : 'm/s';
            return speed.toFixed(1) + ' ' + unit;
        }
        
        function formatPrecipitation(mm) {
            if (mm === null || mm === undefined || mm === 0) return null;
            const amount = useImperial ? millimetersToInches(mm) : mm;
            const unit = useImperial ? 'in' : 'mm';
            return amount.toFixed(2) + ' ' + unit;
        }
        
        // Dark mode toggle
        function toggleDarkMode() {
            darkMode = !darkMode;
            if (darkMode) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').textContent = '‚òÄÔ∏è Light';
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('darkModeToggle').textContent = 'üåô Dark';
            }
            localStorage.setItem('darkMode', darkMode);
            
            // Reload content if it's already displayed to update colors
            const cityInput = document.getElementById('cityInput');
            if (cityInput && cityInput.value.trim()) {
                // Reload Wikipedia content
                loadWikipedia(cityInput.value.trim());
                
                // Reload weather chart if location ID is available
                if (cityInput.dataset.lastLocationId) {
                    loadWeather(parseInt(cityInput.dataset.lastLocationId));
                }
            }
        }
        
        // Unit system toggle (Imperial/Metric)
        function toggleUnitSystem() {
            useImperial = !useImperial;
            const button = document.getElementById('unitToggle');
            if (useImperial) {
                button.textContent = 'Metric / Imperial';
                button.classList.add('active');
            } else {
                button.textContent = 'Imperial / Metric';
                button.classList.remove('active');
            }
            localStorage.setItem('useImperial', useImperial);
            // Refresh weather display if data is already loaded
            const contentEl = document.getElementById('content');
            if (contentEl && contentEl.style.display !== 'none') {
                const cityInput = document.getElementById('cityInput');
                if (cityInput && cityInput.dataset.lastLocationId) {
                    loadWeather(parseInt(cityInput.dataset.lastLocationId));
                }
            }
        }
        
        // Load preferences from localStorage
        function loadPreferences() {
            const savedDarkMode = localStorage.getItem('darkMode');
            const savedUseImperial = localStorage.getItem('useImperial');
            
            if (savedDarkMode === 'true') {
                darkMode = true;
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').textContent = '‚òÄÔ∏è Light';
            }
            
            if (savedUseImperial === 'true') {
                useImperial = true;
                const button = document.getElementById('unitToggle');
                button.textContent = 'Metric / Imperial';
                button.classList.add('active');
            }
        }
        
        let searchTimeout = null;
        let selectedCity = null;
        
        // Search for cities as user types
        async function searchCities(query) {
            if (!query || query.length < 2) {
                hideSuggestions();
                return;
            }
            
            const countryInput = document.getElementById('countryInput');
            const country = countryInput ? countryInput.value.trim() : '';
            
            try {
                const params = new URLSearchParams({ q: query });
                if (country) {
                    params.append('country', country);
                }
                
                const response = await fetch(`/api/search-cities?${params}`);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    showSuggestions(data.results);
                } else {
                    hideSuggestions();
                }
            } catch (error) {
                console.error('Error searching cities:', error);
                hideSuggestions();
            }
        }
        
        // Show suggestions dropdown
        function showSuggestions(results) {
            const suggestionsEl = document.getElementById('citySuggestions');
            if (!suggestionsEl) return;
            
            suggestionsEl.innerHTML = results.map(result => `
                <div class="suggestion-item" data-city="${result.city}" data-region="${result.region}" data-country="${result.country}" data-lat="${result.latitude}" data-lon="${result.longitude}">
                    <div class="suggestion-name">${result.display_name}</div>
                    <div class="suggestion-details">${result.full_address}</div>
                </div>
            `).join('');
            
            suggestionsEl.style.display = 'block';
            
            // Add click handlers
            suggestionsEl.querySelectorAll('.suggestion-item').forEach(item => {
                item.addEventListener('click', function() {
                    selectCity({
                        city: this.dataset.city,
                        region: this.dataset.region,
                        country: this.dataset.country,
                        latitude: parseFloat(this.dataset.lat),
                        longitude: parseFloat(this.dataset.lon),
                        display_name: this.querySelector('.suggestion-name').textContent
                    });
                });
            });
        }
        
        // Hide suggestions dropdown
        function hideSuggestions() {
            const suggestionsEl = document.getElementById('citySuggestions');
            if (suggestionsEl) {
                suggestionsEl.style.display = 'none';
            }
        }
        
        // Select a city from suggestions
        function selectCity(cityData) {
            const cityInput = document.getElementById('cityInput');
            const countryInput = document.getElementById('countryInput');
            
            if (cityInput) {
                cityInput.value = cityData.display_name;
            }
            if (countryInput && cityData.country) {
                countryInput.value = cityData.country;
            }
            
            selectedCity = cityData;
            hideSuggestions();
            
            // Auto-submit the form
            const form = document.getElementById('searchForm');
            if (form) {
                form.dispatchEvent(new Event('submit'));
            }
        }
        
        async function lookupCity() {
            console.log('lookupCity called'); // Debug log
            const cityInput = document.getElementById('cityInput');
            const countryInput = document.getElementById('countryInput');
            const statusEl = document.getElementById('status');
            const contentEl = document.getElementById('content');
            const emptyStateEl = document.getElementById('emptyState');
            
            if (!cityInput) {
                console.error('cityInput not found');
                return;
            }
            
            const cityName = cityInput.value.trim();
            console.log('City name:', cityName); // Debug log
            
            if (!cityName) {
                statusEl.style.display = 'block';
                statusEl.className = 'status error';
                statusEl.textContent = 'Please enter a city name';
                return;
            }
            
            // Show loading state
            statusEl.style.display = 'block';
            statusEl.className = 'status loading';
            statusEl.textContent = 'Looking up city and fetching data...';
            contentEl.style.display = 'none';
            emptyStateEl.style.display = 'none';
            
            try {
            // Use selected city coordinates if available, otherwise use city name
            const requestBody = {
                city_name: cityName,
                country: countryInput.value.trim() || null
            };
            
            if (selectedCity && selectedCity.latitude && selectedCity.longitude) {
                requestBody.latitude = selectedCity.latitude;
                requestBody.longitude = selectedCity.longitude;
                requestBody.city = selectedCity.city;
                requestBody.region = selectedCity.region;
            }
            
            const response = await fetch('/api/lookup-city', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });
                
                const data = await response.json();
                
                if (data.error) {
                    statusEl.className = 'status error';
                    statusEl.textContent = `Error: ${data.error}`;
                    contentEl.style.display = 'none';
                    emptyStateEl.style.display = 'block';
                    return;
                }
                
                statusEl.className = 'status success';
                statusEl.textContent = `‚úÖ Successfully loaded data for ${data.location.name}!`;
                
                // Hide status after 3 seconds
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
                
                // Store location ID for temperature unit refresh
                cityInput.dataset.lastLocationId = data.location.id;
                
                // Load weather and Wikipedia
                await loadWeather(data.location.id);
                // Use city name for Wikipedia lookup (not the full display name)
                const wikipediaQuery = selectedCity ? selectedCity.city : data.location.name;
                await loadWikipedia(wikipediaQuery);
                
                contentEl.style.display = 'flex';
                emptyStateEl.style.display = 'none';
                
            } catch (error) {
                statusEl.className = 'status error';
                statusEl.textContent = `Error: ${error.message}`;
                contentEl.style.display = 'none';
                emptyStateEl.style.display = 'block';
            }
        }
        
        // Set up form submission handler and city search
        (function() {
            function setupFormHandler() {
                const searchForm = document.getElementById('searchForm');
                const cityInput = document.getElementById('cityInput');
                
                if (searchForm) {
                    searchForm.addEventListener('submit', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Form submitted'); // Debug log
                        hideSuggestions();
                        lookupCity();
                        return false;
                    });
                    console.log('Form handler attached');
                } else {
                    console.error('searchForm not found');
                }
                
                // Set up city input search
                if (cityInput) {
                    cityInput.addEventListener('input', function(e) {
                        const query = e.target.value.trim();
                        selectedCity = null; // Clear selection when user types
                        
                        // Clear existing timeout
                        if (searchTimeout) {
                            clearTimeout(searchTimeout);
                        }
                        
                        // Debounce search
                        searchTimeout = setTimeout(() => {
                            searchCities(query);
                        }, 300);
                    });
                    
                    // Hide suggestions when clicking outside
                    document.addEventListener('click', function(e) {
                        const suggestionsEl = document.getElementById('citySuggestions');
                        if (suggestionsEl && !suggestionsEl.contains(e.target) && e.target !== cityInput) {
                            hideSuggestions();
                        }
                    });
                }
            }
            
            // Try immediately, then on DOMContentLoaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupFormHandler);
            } else {
                setupFormHandler();
            }
        })();
        
        // Make functions available globally
        window.lookupCity = lookupCity;
        window.toggleDarkMode = toggleDarkMode;
        window.toggleUnitSystem = toggleUnitSystem;
        
        // Load preferences on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadPreferences);
        } else {
            loadPreferences();
        }
        
        async function loadWeather(locationId) {
            const weatherContentEl = document.getElementById('weatherContent');
            
            try {
                const response = await fetch(`/api/location/${locationId}/weather`);
                const data = await response.json();
                
                if (data.error || !data.observations || data.observations.length === 0) {
                    weatherContentEl.innerHTML = '<div class="error">No weather data available</div>';
                    return;
                }
                
                // Get today's date in user's local timezone
                const now = new Date();
                // Get local date components directly (not UTC)
                const localYear = now.getFullYear();
                const localMonth = now.getMonth();
                const localDay = now.getDate();
                
                // Format as YYYY-MM-DD in local timezone
                const year = localYear;
                const month = String(localMonth + 1).padStart(2, '0');
                const day = String(localDay).padStart(2, '0');
                const todayKey = `${year}-${month}-${day}`;
                
                console.log('Today in local timezone:', todayKey, 'Current time:', now.toLocaleString());
                
                // Group observations by day (convert UTC to local time for display)
                const dailyData = {};
                data.observations.forEach(obs => {
                    // Parse UTC date string - JavaScript Date automatically converts to local timezone
                    const obsDate = new Date(obs.observed_at);
                    
                    // Get local date components (these are already in user's timezone)
                    const obsLocalYear = obsDate.getFullYear();
                    const obsLocalMonth = obsDate.getMonth();
                    const obsLocalDay = obsDate.getDate();
                    
                    // Create day key in local timezone
                    const year = obsLocalYear;
                    const month = String(obsLocalMonth + 1).padStart(2, '0');
                    const day = String(obsLocalDay).padStart(2, '0');
                    const dayKey = `${year}-${month}-${day}`;
                    
                    if (!dailyData[dayKey]) {
                        dailyData[dayKey] = {
                            date: dayKey,
                            temps: [],
                            humidities: [],
                            windSpeeds: []
                        };
                    }
                    
                    if (obs.temperature_celsius !== null) {
                        dailyData[dayKey].temps.push(obs.temperature_celsius);
                    }
                    if (obs.humidity_percent !== null) {
                        dailyData[dayKey].humidities.push(obs.humidity_percent);
                    }
                    if (obs.wind_speed_mps !== null) {
                        dailyData[dayKey].windSpeeds.push(obs.wind_speed_mps);
                    }
                });
                
                // Get current time in user's local timezone
                const currentTime = new Date();
                
                // Sort observations by time - include all observations for current weather selection
                // (we'll filter for display separately)
                const sortedObservations = data.observations
                    .sort((a, b) => new Date(a.observed_at) - new Date(b.observed_at));
                
                // Filter for display (7-day view: 3 days ago to 3 days ahead)
                const displayObservations = sortedObservations.filter(obs => {
                    const obsDate = new Date(obs.observed_at);
                    const daysDiff = (obsDate - currentTime) / (1000 * 60 * 60 * 24);
                    return daysDiff >= -3.5 && daysDiff <= 3.5;
                });
                
                console.log(`Total observations: ${data.observations.length}, For display: ${displayObservations.length}`);
                if (sortedObservations.length > 0) {
                    const firstObs = new Date(sortedObservations[0].observed_at);
                    const lastObs = new Date(sortedObservations[sortedObservations.length - 1].observed_at);
                    console.log(`First observation: ${firstObs.toLocaleString()}, Last: ${lastObs.toLocaleString()}`);
                }
                
                // Group by day for organization (using local timezone) - use displayObservations for the forecast
                // Filter to only show current hour and future hours (hide past hours for today)
                // Estimate city timezone for proper filtering
                let cityTimezone = 'America/New_York';
                if (data.location.latitude && data.location.longitude) {
                    const lat = data.location.latitude;
                    const lon = data.location.longitude;
                    const country = (data.location.country || '').toLowerCase();
                    
                    if (country.includes('united states') || country.includes('usa') || !country) {
                        if (lon < -102) {
                            cityTimezone = lon < -115 ? 'America/Los_Angeles' : 'America/Denver';
                        } else if (lon < -85) {
                            cityTimezone = 'America/Chicago';
                        } else {
                            cityTimezone = 'America/New_York';
                        }
                    } else if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 70) {
                        if (lon < 5) cityTimezone = 'Europe/London';
                        else if (lon < 15) cityTimezone = 'Europe/Paris';
                        else if (lon < 30) cityTimezone = 'Europe/Moscow';
                        else cityTimezone = 'Europe/London';
                    } else if (lon >= 70 && lon <= 150 && lat >= 0 && lat <= 60) {
                        if (lon < 100) cityTimezone = 'Asia/Shanghai';
                        else if (lon < 135) cityTimezone = 'Asia/Tokyo';
                        else cityTimezone = 'Asia/Shanghai';
                    }
                }
                
                // Get current time in city's timezone for filtering
                const nowForFilter = new Date();
                const cityTimeFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: cityTimezone,
                    hour: 'numeric',
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
                const nowCityParts = cityTimeFormatter.formatToParts(nowForFilter);
                const nowCityYear = parseInt(nowCityParts.find(p => p.type === 'year').value);
                const nowCityMonth = parseInt(nowCityParts.find(p => p.type === 'month').value) - 1;
                const nowCityDay = parseInt(nowCityParts.find(p => p.type === 'day').value);
                const nowCityHour = parseInt(nowCityParts.find(p => p.type === 'hour').value);
                
                const filteredForDisplay = displayObservations.filter(obs => {
                    const obsDateStr = obs.observed_at;
                    const hasTimezone = obsDateStr.includes('+') || obsDateStr.includes('Z') || 
                                       (obsDateStr.match(/[+-]\d{2}:\d{2}$/) !== null);
                    
                    let obsYear, obsMonth, obsDay, obsHour;
                    if (!hasTimezone) {
                        const normalized = obsDateStr.replace(' ', 'T');
                        const parts = normalized.split('T');
                        if (parts.length >= 2) {
                            const datePart = parts[0].split('-');
                            const timePart = parts[1].split(':');
                            obsYear = parseInt(datePart[0]);
                            obsMonth = parseInt(datePart[1]) - 1;
                            obsDay = parseInt(datePart[2]);
                            obsHour = parseInt(timePart[0]);
                        } else {
                            return true; // Include if can't parse
                        }
                    } else {
                        const obsDate = new Date(obsDateStr);
                        const obsCityParts = cityTimeFormatter.formatToParts(obsDate);
                        obsYear = parseInt(obsCityParts.find(p => p.type === 'year').value);
                        obsMonth = parseInt(obsCityParts.find(p => p.type === 'month').value) - 1;
                        obsDay = parseInt(obsCityParts.find(p => p.type === 'day').value);
                        obsHour = parseInt(obsCityParts.find(p => p.type === 'hour').value);
                    }
                    
                    // Check if same day as current time in city timezone
                    const sameDay = (obsYear === nowCityYear && obsMonth === nowCityMonth && obsDay === nowCityDay);
                    
                    // Check if this is a past day
                    const obsDateObj = new Date(obsYear, obsMonth, obsDay);
                    const nowDateObj = new Date(nowCityYear, nowCityMonth, nowCityDay);
                    const isPastDay = obsDateObj < nowDateObj;
                    
                    if (isPastDay) {
                        // Exclude all past days
                        return false;
                    } else if (sameDay) {
                        // For today: only show current hour and future hours
                        return obsHour >= nowCityHour;
                    } else {
                        // For future days: show all hours
                        return true;
                    }
                });
                
                const hoursByDay = {};
                filteredForDisplay.forEach(obs => {
                    // Parse the UTC date string and convert to local time
                    const obsDate = new Date(obs.observed_at);
                    
                    // Get local date components (this automatically converts from UTC to local)
                    const localYear = obsDate.getFullYear();
                    const localMonth = obsDate.getMonth();
                    const localDay = obsDate.getDate();
                    
                    // Create day key in local timezone
                    const year = localYear;
                    const month = String(localMonth + 1).padStart(2, '0');
                    const day = String(localDay).padStart(2, '0');
                    const dayKey = `${year}-${month}-${day}`;
                    const isToday = dayKey === todayKey;
                    
                    if (!hoursByDay[dayKey]) {
                        // Format day name using local date components
                        // Create a date object from local components to ensure correct day name
                        const localDateObj = new Date(localYear, localMonth, localDay);
                        let dayName;
                        // Double-check isToday to make sure it's really today
                        const actualIsToday = (dayKey === todayKey);
                        if (actualIsToday) {
                            dayName = 'Today';
                        } else {
                            // Use the local date object to format the day name
                            dayName = localDateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                        }
                        
                        console.log(`Day key: ${dayKey}, todayKey: ${todayKey}, isToday: ${actualIsToday}, dayName: ${dayName}`);
                        
                        hoursByDay[dayKey] = {
                            dayName: dayName,
                            isToday: actualIsToday,
                            hours: []
                        };
                    }
                    
                    // Display time in local timezone
                    const timeStr = obsDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                    
                    // Determine if this is the "current" hour - the hour that contains the current time
                    // Get the hour component of both the observation and current time
                    const obsHour = obsDate.getHours();
                    const currentHour = currentTime.getHours();
                    const obsDateOnly = new Date(obsDate.getFullYear(), obsDate.getMonth(), obsDate.getDate());
                    const currentDateOnly = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());
                    
                    // It's "Now" if it's the same day and same hour as the current time
                    // Also check if the observation is in the past but within the last hour
                    const isSameDay = obsDateOnly.getTime() === currentDateOnly.getTime();
                    const isSameHour = obsHour === currentHour;
                    const timeDiff = currentTime - obsDate;
                    const isRecentPast = timeDiff >= 0 && timeDiff < 60 * 60 * 1000; // Within last hour
                    const isNow = isSameDay && (isSameHour || isRecentPast);
                    
                    hoursByDay[dayKey].hours.push({
                        time: timeStr,
                        datetime: obsDate,
                        isNow: isNow,
                        temp: obs.temperature_celsius,
                        humidity: obs.humidity_percent,
                        wind: obs.wind_speed_mps,
                        precipitation: obs.precipitation_mm,
                        cloudCover: obs.cloud_cover_percent
                    });
                });
                
                // Find current weather - prefer the observation closest to now in city's timezone
                let currentWeather = null;
                if (sortedObservations.length > 0) {
                    // Estimate city timezone first (needed for proper time comparison)
                    let cityTimezone = 'America/New_York';
                    if (data.location.latitude && data.location.longitude) {
                        const lat = data.location.latitude;
                        const lon = data.location.longitude;
                        const country = (data.location.country || '').toLowerCase();
                        
                        if (country.includes('united states') || country.includes('usa') || !country) {
                            if (lon < -102) {
                                cityTimezone = lon < -115 ? 'America/Los_Angeles' : 'America/Denver';
                            } else if (lon < -85) {
                                cityTimezone = 'America/Chicago';
                            } else {
                                cityTimezone = 'America/New_York';
                            }
                        } else if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 70) {
                            if (lon < 5) cityTimezone = 'Europe/London';
                            else if (lon < 15) cityTimezone = 'Europe/Paris';
                            else if (lon < 30) cityTimezone = 'Europe/Moscow';
                            else cityTimezone = 'Europe/London';
                        } else if (lon >= 70 && lon <= 150 && lat >= 0 && lat <= 60) {
                            if (lon < 100) cityTimezone = 'Asia/Shanghai';
                            else if (lon < 135) cityTimezone = 'Asia/Tokyo';
                            else cityTimezone = 'Asia/Shanghai';
                        }
                    }
                    
                    // Get current time in city's timezone
                    const now = new Date();
                    const cityTimeFormatter = new Intl.DateTimeFormat('en-US', {
                        timeZone: cityTimezone,
                        hour: 'numeric',
                        hour12: false,
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });
                    
                    // Parse current time in city timezone
                    const nowCityParts = cityTimeFormatter.formatToParts(now);
                    const nowCityYear = parseInt(nowCityParts.find(p => p.type === 'year').value);
                    const nowCityMonth = parseInt(nowCityParts.find(p => p.type === 'month').value) - 1; // 0-indexed
                    const nowCityDay = parseInt(nowCityParts.find(p => p.type === 'day').value);
                    const nowCityHour = parseInt(nowCityParts.find(p => p.type === 'hour').value);
                    
                    console.log(`Current time in ${cityTimezone}: ${nowCityYear}-${nowCityMonth+1}-${nowCityDay} ${nowCityHour}:00`);
                    
                    let bestObs = null;
                    let bestScore = -Infinity;
                    
                    sortedObservations.forEach(obs => {
                        // Parse observation timestamp - treat it as if it's in city timezone
                        // (since API returns data in city timezone, but DB stores without TZ)
                        const obsDateStr = obs.observed_at;
                        
                        // Check if timestamp has timezone info (has +, Z, or timezone offset like -05:00)
                        const hasTimezone = obsDateStr.includes('+') || obsDateStr.includes('Z') || 
                                           (obsDateStr.match(/[+-]\d{2}:\d{2}$/) !== null);
                        
                        let obsYear, obsMonth, obsDay, obsHour;
                        
                        if (!hasTimezone) {
                            // No timezone info - treat as city timezone
                            // Handle both "2025-11-08T00:00:00" and "2025-11-08 00:00:00" formats
                            const normalized = obsDateStr.replace(' ', 'T');
                            const parts = normalized.split('T');
                            if (parts.length >= 2) {
                                const datePart = parts[0].split('-');
                                const timePart = parts[1].split(':');
                                obsYear = parseInt(datePart[0]);
                                obsMonth = parseInt(datePart[1]) - 1; // 0-indexed
                                obsDay = parseInt(datePart[2]);
                                obsHour = parseInt(timePart[0]);
                            } else {
                                return; // Skip invalid timestamp
                            }
                        } else {
                            // Has timezone info - convert to city timezone
                            const obsDate = new Date(obsDateStr);
                            const obsCityParts = cityTimeFormatter.formatToParts(obsDate);
                            obsYear = parseInt(obsCityParts.find(p => p.type === 'year').value);
                            obsMonth = parseInt(obsCityParts.find(p => p.type === 'month').value) - 1;
                            obsDay = parseInt(obsCityParts.find(p => p.type === 'day').value);
                            obsHour = parseInt(obsCityParts.find(p => p.type === 'hour').value);
                        }
                        
                        // Compare with current time in city timezone
                        const sameDay = (obsYear === nowCityYear && obsMonth === nowCityMonth && obsDay === nowCityDay);
                        const sameHour = (obsHour === nowCityHour);
                        const nextHour = (obsHour === nowCityHour + 1) || (nowCityHour === 23 && obsHour === 0);
                        const prevHour = (obsHour === nowCityHour - 1) || (nowCityHour === 0 && obsHour === 23);
                        
                        let score = 0;
                        
                        if (sameDay && sameHour) {
                            // Perfect match - current hour
                            score = 10000;
                        } else if (sameDay && nextHour) {
                            // Next hour on same day (forecast) - strongly prefer
                            score = 8000;
                        } else if (sameDay && prevHour) {
                            // Previous hour on same day (recent past)
                            score = 6000;
                        } else if (sameDay) {
                            // Same day, different hour
                            const hourDiff = Math.abs(obsHour - nowCityHour);
                            // Prefer future hours over past hours
                            if (obsHour > nowCityHour) {
                                score = 5000 - (hourDiff * 50); // Future hours
                            } else {
                                score = 3000 - (hourDiff * 100); // Past hours
                            }
                        } else {
                            // Different day - calculate day difference
                            const obsDateObj = new Date(obsYear, obsMonth, obsDay, obsHour);
                            const nowDateObj = new Date(nowCityYear, nowCityMonth, nowCityDay, nowCityHour);
                            const dayDiff = Math.abs((obsDateObj - nowDateObj) / (1000 * 60 * 60 * 24));
                            
                            if (dayDiff <= 1) {
                                // Prefer future days
                                if (obsDateObj > nowDateObj) {
                                    score = 2000 - (dayDiff * 500);
                                } else {
                                    score = 1000 - (dayDiff * 500);
                                }
                            } else {
                                score = 0; // Too far away
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestObs = obs;
                            console.log(`New best observation: ${obsYear}-${obsMonth+1}-${obsDay} ${obsHour}:00, score: ${score}`);
                        }
                    });
                    
                    if (bestObs) {
                        const bestParts = bestObs.observed_at.replace(' ', 'T').split('T');
                        console.log(`Selected current weather: ${bestObs.observed_at} (best score: ${bestScore})`);
                    }
                    
                    currentWeather = bestObs || sortedObservations[sortedObservations.length - 1];
                }
                
                // Render current weather card
                let html = '';
                if (currentWeather) {
                    // Get city's timezone from coordinates and country
                    // Estimate timezone from longitude and country
                    let cityTimezone = 'America/New_York'; // Default
                    if (data.location.latitude && data.location.longitude) {
                        const lat = data.location.latitude;
                        const lon = data.location.longitude;
                        const country = (data.location.country || '').toLowerCase();
                        
                        // US timezones (based on longitude)
                        if (country.includes('united states') || country.includes('usa') || !country) {
                            if (lon < -102) {
                                cityTimezone = lon < -115 ? 'America/Los_Angeles' : 'America/Denver';
                            } else if (lon < -85) {
                                cityTimezone = 'America/Chicago';
                            } else {
                                cityTimezone = 'America/New_York';
                            }
                        }
                        // Europe (rough estimate)
                        else if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 70) {
                            if (lon < 5) cityTimezone = 'Europe/London';
                            else if (lon < 15) cityTimezone = 'Europe/Paris';
                            else if (lon < 30) cityTimezone = 'Europe/Moscow';
                            else cityTimezone = 'Europe/London';
                        }
                        // Asia
                        else if (lon >= 70 && lon <= 150 && lat >= 0 && lat <= 60) {
                            if (lon < 100) cityTimezone = 'Asia/Shanghai';
                            else if (lon < 135) cityTimezone = 'Asia/Tokyo';
                            else cityTimezone = 'Asia/Shanghai';
                        }
                        // Australia
                        else if (lon >= 110 && lon <= 155 && lat >= -45 && lat <= -10) {
                            if (lon < 142) cityTimezone = 'Australia/Adelaide';
                            else if (lon < 150) cityTimezone = 'Australia/Sydney';
                            else cityTimezone = 'Australia/Melbourne';
                        }
                        // Default: estimate from longitude (15 degrees per timezone)
                        else {
                            const timezoneOffset = Math.round(lon / 15);
                            // Use UTC as base and estimate
                            cityTimezone = 'UTC'; // Fallback, will show in UTC
                        }
                    }
                    
                    // Get actual current time in city's timezone
                    const nowInCity = new Date();
                    const cityTime = nowInCity.toLocaleString('en-US', { 
                        timeZone: cityTimezone,
                        weekday: 'long', 
                        month: 'long', 
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                    
                    // Also show the observation time for reference
                    const obsDate = new Date(currentWeather.observed_at);
                    const obsTime = obsDate.toLocaleString('en-US', { 
                        timeZone: cityTimezone,
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                    
                    html += `<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 20px;">
                            <div>
                                <h2 style="color: white; margin-bottom: 10px; font-size: 2em;">Current Weather</h2>
                                <p style="color: rgba(255,255,255,0.9); font-size: 1.1em; margin-bottom: 5px;">${data.location.city}, ${data.location.region || data.location.country}</p>
                                <p style="color: rgba(255,255,255,0.9); font-size: 1em; font-weight: 500; margin-bottom: 3px;">${cityTime}</p>
                                <p style="color: rgba(255,255,255,0.7); font-size: 0.85em;">Weather data from ${obsTime}</p>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 4em; font-weight: bold; line-height: 1;">
                                    ${formatTemperature(currentWeather.temperature_celsius)}
                                </div>
                                <div style="display: flex; gap: 20px; margin-top: 15px; font-size: 0.95em;">
                                    ${currentWeather.humidity_percent !== null ? `
                                        <div>
                                            <div style="opacity: 0.8;">Humidity</div>
                                            <div style="font-weight: bold; font-size: 1.2em;">${currentWeather.humidity_percent.toFixed(0)}%</div>
                                        </div>
                                    ` : ''}
                                    ${currentWeather.wind_speed_mps !== null ? `
                                        <div>
                                            <div style="opacity: 0.8;">Wind</div>
                                            <div style="font-weight: bold; font-size: 1.2em;">${formatWindSpeed(currentWeather.wind_speed_mps)}</div>
                                        </div>
                                    ` : ''}
                                    ${currentWeather.cloud_cover_percent !== null ? `
                                        <div>
                                            <div style="opacity: 0.8;">Clouds</div>
                                            <div style="font-weight: bold; font-size: 1.2em;">${currentWeather.cloud_cover_percent.toFixed(0)}%</div>
                                        </div>
                                    ` : ''}
                                    ${currentWeather.precipitation_mm !== null && currentWeather.precipitation_mm > 0 ? `
                                        <div>
                                            <div style="opacity: 0.8;">Precipitation</div>
                                            <div style="font-weight: bold; font-size: 1.2em;">${formatPrecipitation(currentWeather.precipitation_mm)}</div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>`;
                }
                
                // Render hourly forecast
                html += '<div class="weather-hours">';
                const daysArray = Object.keys(hoursByDay).sort();
                
                daysArray.forEach(dayKey => {
                    const dayData = hoursByDay[dayKey];
                    // Skip empty days
                    if (dayData.hours.length === 0) {
                        return;
                    }
                    html += `<div style="margin-bottom: 25px;">
                        <h3 style="color: #667eea; margin-bottom: 15px; font-size: 1.2em; font-weight: 600;">${dayData.dayName}</h3>
                        ${dayData.hours.map(hour => {
                            const isTodayHour = hour.isNow || dayData.isToday;
                            return `
                            <div class="weather-hour ${isTodayHour ? 'today' : ''}">
                                <div class="hour-time ${isTodayHour ? 'today' : ''}">
                                    ${hour.isNow ? 'üïê Now' : hour.time}
                                </div>
                                <div class="hour-temp">${formatTemperature(hour.temp)}</div>
                                <div class="hour-main-details">
                                    <div class="hour-details">
                                        ${hour.humidity !== null ? `
                                            <div class="hour-detail">
                                                <span class="hour-detail-icon">üíß</span>
                                                <div>
                                                    <div class="hour-detail-label">Humidity</div>
                                                    <div class="hour-detail-value">${hour.humidity.toFixed(0)}%</div>
                                                </div>
                                            </div>
                                        ` : ''}
                                        ${hour.wind !== null ? `
                                            <div class="hour-detail">
                                                <span class="hour-detail-icon">üí®</span>
                                                <div>
                                                    <div class="hour-detail-label">Wind</div>
                                                    <div class="hour-detail-value">${formatWindSpeed(hour.wind)}</div>
                                                </div>
                                            </div>
                                        ` : ''}
                                        ${hour.precipitation !== null && hour.precipitation > 0 ? `
                                            <div class="hour-detail" style="background: #e3f2fd; border-left: 3px solid #2196f3;">
                                                <span class="hour-detail-icon">üåßÔ∏è</span>
                                                <div>
                                                    <div class="hour-detail-label">Precipitation</div>
                                                    <div class="hour-detail-value" style="color: #1976d2; font-weight: 700;">${formatPrecipitation(hour.precipitation)}</div>
                                                </div>
                                            </div>
                                        ` : ''}
                                        ${hour.cloudCover !== null ? `
                                            <div class="hour-detail">
                                                <span class="hour-detail-icon">‚òÅÔ∏è</span>
                                                <div>
                                                    <div class="hour-detail-label">Clouds</div>
                                                    <div class="hour-detail-value">${hour.cloudCover.toFixed(0)}%</div>
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                        }).join('')}
                    </div>`;
                });
                
                html += '</div>';
                weatherContentEl.innerHTML = html;
                
                // Create chart with filtered data (same as display - no past days, current hour onwards for today)
                // Estimate city timezone for chart (reuse the same logic)
                let chartCityTimezone = 'America/New_York';
                if (data.location.latitude && data.location.longitude) {
                    const lat = data.location.latitude;
                    const lon = data.location.longitude;
                    const country = (data.location.country || '').toLowerCase();
                    
                    if (country.includes('united states') || country.includes('usa') || !country) {
                        if (lon < -102) {
                            chartCityTimezone = lon < -115 ? 'America/Los_Angeles' : 'America/Denver';
                        } else if (lon < -85) {
                            chartCityTimezone = 'America/Chicago';
                        } else {
                            chartCityTimezone = 'America/New_York';
                        }
                    } else if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 70) {
                        if (lon < 5) chartCityTimezone = 'Europe/London';
                        else if (lon < 15) chartCityTimezone = 'Europe/Paris';
                        else if (lon < 30) chartCityTimezone = 'Europe/Moscow';
                        else chartCityTimezone = 'Europe/London';
                    } else if (lon >= 70 && lon <= 150 && lat >= 0 && lat <= 60) {
                        if (lon < 100) chartCityTimezone = 'Asia/Shanghai';
                        else if (lon < 135) chartCityTimezone = 'Asia/Tokyo';
                        else chartCityTimezone = 'Asia/Shanghai';
                    }
                }
                
                // Get current time in city's timezone for chart filtering
                const nowForChart = new Date();
                const chartTimeFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: chartCityTimezone,
                    hour: 'numeric',
                    hour12: false,
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
                const nowChartParts = chartTimeFormatter.formatToParts(nowForChart);
                const nowChartYear = parseInt(nowChartParts.find(p => p.type === 'year').value);
                const nowChartMonth = parseInt(nowChartParts.find(p => p.type === 'month').value) - 1;
                const nowChartDay = parseInt(nowChartParts.find(p => p.type === 'day').value);
                const nowChartHour = parseInt(nowChartParts.find(p => p.type === 'hour').value);
                
                // Filter chart data same way as display
                const chartData = data.observations
                    .filter(obs => {
                        if (obs.temperature_celsius === null) return false;
                        
                        const obsDateStr = obs.observed_at;
                        const hasTimezone = obsDateStr.includes('+') || obsDateStr.includes('Z') || 
                                           (obsDateStr.match(/[+-]\d{2}:\d{2}$/) !== null);
                        
                        let obsYear, obsMonth, obsDay, obsHour;
                        if (!hasTimezone) {
                            const normalized = obsDateStr.replace(' ', 'T');
                            const parts = normalized.split('T');
                            if (parts.length >= 2) {
                                const datePart = parts[0].split('-');
                                const timePart = parts[1].split(':');
                                obsYear = parseInt(datePart[0]);
                                obsMonth = parseInt(datePart[1]) - 1;
                                obsDay = parseInt(datePart[2]);
                                obsHour = parseInt(timePart[0]);
                            } else {
                                return false;
                            }
                        } else {
                            const obsDate = new Date(obsDateStr);
                            const obsChartParts = chartTimeFormatter.formatToParts(obsDate);
                            obsYear = parseInt(obsChartParts.find(p => p.type === 'year').value);
                            obsMonth = parseInt(obsChartParts.find(p => p.type === 'month').value) - 1;
                            obsDay = parseInt(obsChartParts.find(p => p.type === 'day').value);
                            obsHour = parseInt(obsChartParts.find(p => p.type === 'hour').value);
                        }
                        
                        // Check if same day as current time in city timezone
                        const sameDay = (obsYear === nowChartYear && obsMonth === nowChartMonth && obsDay === nowChartDay);
                        
                        // Check if this is a past day
                        const obsDateObj = new Date(obsYear, obsMonth, obsDay);
                        const nowDateObj = new Date(nowChartYear, nowChartMonth, nowChartDay);
                        const isPastDay = obsDateObj < nowDateObj;
                        
                        if (isPastDay) {
                            return false;
                        } else if (sameDay) {
                            return obsHour >= nowChartHour;
                        } else {
                            return true;
                        }
                    })
                    .sort((a, b) => new Date(a.observed_at) - new Date(b.observed_at))
                    .slice(0, 72); // Show up to 72 hours (3 days)
                
                if (chartData.length > 0) {
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'chart-container';
                    chartContainer.innerHTML = '<canvas id="weatherChart"></canvas>';
                    weatherContentEl.appendChild(chartContainer);
                    
                    const ctx = document.getElementById('weatherChart').getContext('2d');
                    
                    if (weatherChart) {
                        weatherChart.destroy();
                    }
                    
                    // Format labels as "MMM DD, HH AM/PM" (better format)
                    const labels = chartData.map(obs => {
                        const date = new Date(obs.observed_at);
                        // Convert to city timezone and format
                        const cityDateStr = date.toLocaleString('en-US', { 
                            timeZone: chartCityTimezone,
                            month: 'short', 
                            day: 'numeric', 
                            hour: 'numeric', 
                            minute: '2-digit',
                            hour12: true 
                        });
                        // Parse and reformat to "MMM DD, HH AM/PM" format
                        // Format: "Nov 8, 2:47 PM" -> "Nov 8, 2 PM"
                        const parts = cityDateStr.split(', ');
                        if (parts.length >= 2) {
                            const datePart = parts[0]; // "Nov 8"
                            const timePart = parts[1]; // "2:47 PM"
                            // Extract hour and AM/PM (avoid duplicate)
                            const timeMatch = timePart.match(/(\d{1,2}):\d{2}\s*(AM|PM)/i);
                            if (timeMatch) {
                                const hour = parseInt(timeMatch[1]);
                                const period = timeMatch[2].toUpperCase();
                                return `${datePart}, ${hour} ${period}`;
                            }
                            // Fallback: try simpler parsing
                            const hourMatch = timePart.match(/(\d{1,2})\s*(AM|PM)/i);
                            if (hourMatch) {
                                const hour = parseInt(hourMatch[1]);
                                const period = hourMatch[2].toUpperCase();
                                return `${datePart}, ${hour} ${period}`;
                            }
                        }
                        // Fallback: try to parse differently
                        const match = cityDateStr.match(/(\w{3} \d{1,2}),? (\d{1,2}):\d{2}\s*(AM|PM)/i);
                        if (match) {
                            const hour = parseInt(match[2]);
                            const period = match[3].toUpperCase();
                            return `${match[1]}, ${hour} ${period}`;
                        }
                        return cityDateStr;
                    });
                    
                    const temps = chartData.map(obs => {
                        if (obs.temperature_celsius === null) return null;
                        return useImperial ? celsiusToFahrenheit(obs.temperature_celsius) : obs.temperature_celsius;
                    });
                    const humidities = chartData.map(obs => obs.humidity_percent);
                    const precipitations = chartData.map(obs => {
                        if (obs.precipitation_mm === null || obs.precipitation_mm === undefined || obs.precipitation_mm === 0) return null;
                        return useImperial ? millimetersToInches(obs.precipitation_mm) : obs.precipitation_mm;
                    });
                    const tempUnit = useImperial ? '¬∞F' : '¬∞C';
                    const precipUnit = useImperial ? 'in' : 'mm';
                    
                    // Dark mode colors
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    const textColor = isDarkMode ? '#e0e0e0' : '#666';
                    const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                    const tickColor = isDarkMode ? '#b0b0b0' : '#666';
                    
                    weatherChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [
                                {
                                    label: `Temperature (${tempUnit})`,
                                    data: temps,
                                    borderColor: 'rgb(102, 126, 234)',
                                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                                    yAxisID: 'y',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    label: 'Humidity (%)',
                                    data: humidities,
                                    borderColor: 'rgb(118, 75, 162)',
                                    backgroundColor: 'rgba(118, 75, 162, 0.1)',
                                    yAxisID: 'y1',
                                    tension: 0.4,
                                    fill: true
                                },
                                {
                                    type: 'bar',
                                    label: `Precipitation (${precipUnit})`,
                                    data: precipitations,
                                    backgroundColor: 'rgba(33, 150, 243, 0.6)',
                                    borderColor: 'rgb(33, 150, 243)',
                                    borderWidth: 1,
                                    yAxisID: 'y2',
                                    order: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: textColor
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: tickColor
                                    },
                                    grid: {
                                        color: gridColor
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    ticks: {
                                        color: tickColor
                                    },
                                    grid: {
                                        color: gridColor
                                    },
                                    title: {
                                        display: true,
                                        text: `Temperature (${tempUnit})`,
                                        color: textColor
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    ticks: {
                                        color: tickColor
                                    },
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: 'Humidity (%)',
                                        color: textColor
                                    }
                                },
                                y2: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    ticks: {
                                        color: tickColor,
                                        maxTicksLimit: 5,
                                        callback: function(value) {
                                            return value.toFixed(2);
                                        }
                                    },
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                    title: {
                                        display: true,
                                        text: `Precipitation (${precipUnit})`,
                                        color: textColor
                                    }
                                }
                            }
                        }
                    });
                }
                
            } catch (error) {
                weatherContentEl.innerHTML = `<div class="error">Error loading weather: ${error.message}</div>`;
            }
        }
        
        async function loadWikipedia(cityName) {
            const wikipediaContentEl = document.getElementById('wikipediaContent');
            
            try {
                // First get all Wikipedia pages
                const pagesResponse = await fetch('/api/wikipedia-pages');
                const pages = await pagesResponse.json();
                
                // Find the matching page - try exact match first, then partial match
                let matchingPage = pages.find(p => 
                    p.title.toLowerCase() === cityName.toLowerCase()
                );
                
                // If no exact match, try to find pages that contain the city name
                if (!matchingPage) {
                    matchingPage = pages.find(p => 
                        p.title.toLowerCase().includes(cityName.toLowerCase()) ||
                        cityName.toLowerCase().includes(p.title.toLowerCase())
                    );
                }
                
                // If still no match, try to fetch Wikipedia data directly via the lookup API
                if (!matchingPage) {
                    // Try to fetch Wikipedia data for this city
                    try {
                        const lookupResponse = await fetch('/api/lookup-city', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                city_name: cityName,
                                country: null
                            })
                        });
                        
                        const lookupData = await lookupResponse.json();
                        if (lookupData.wikipedia_success) {
                            // Wikipedia data was fetched, reload pages
                            const pagesResponse2 = await fetch('/api/wikipedia-pages');
                            const pages2 = await pagesResponse2.json();
                            matchingPage = pages2.find(p => 
                                p.title.toLowerCase().includes(cityName.toLowerCase())
                            );
                        }
                    } catch (e) {
                        console.log('Could not fetch Wikipedia data:', e);
                    }
                }
                
                if (!matchingPage) {
                    wikipediaContentEl.innerHTML = `<div class="error">Wikipedia article not found for "${cityName}". Try searching with the full city name (e.g., "Hartford, Connecticut").</div>`;
                    return;
                }
                
                // Get page details
                const detailResponse = await fetch(`/api/wikipedia/${matchingPage.page_id}`);
                const details = await detailResponse.json();
                
                if (details.error || !details.summary) {
                    wikipediaContentEl.innerHTML = '<div class="error">Wikipedia article content not available</div>';
                    return;
                }
                
                const summary = details.summary;
                
                // Format the extract with better paragraph breaks
                const extract = summary.extract || 'No content available';
                // Split by double newlines first (paragraph breaks), then by single newlines
                const paragraphs = extract.split(/\n\n+/).filter(p => p.trim().length > 0);
                
                // Use the title from summary, or fall back to cityName, but don't duplicate
                const displayTitle = summary.title || cityName;
                
                // Check if dark mode is active
                const isDarkMode = document.body.classList.contains('dark-mode');
                const titleColor = isDarkMode ? '#e0e0e0' : '#333';
                const textColor = isDarkMode ? '#d0d0d0' : '#444';
                const descriptionColor = isDarkMode ? '#a0c4ff' : '#667eea';
                const borderColor = isDarkMode ? '#444' : '#eee';
                const shadowColor = isDarkMode ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.1)';
                
                wikipediaContentEl.innerHTML = `
                    <div class="wikipedia-content" style="line-height: 1.8; font-size: 1.05em;">
                        <div style="display: flex; gap: 30px; margin-bottom: 30px; align-items: flex-start;">
                            ${summary.thumbnail ? `
                                <img src="${summary.thumbnail}" alt="${displayTitle}" 
                                     style="max-width: 300px; width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px ${shadowColor}; flex-shrink: 0; object-fit: cover;">
                            ` : ''}
                            <div style="flex: 1;">
                                <h3 style="font-size: 2.2em; margin-bottom: 15px; color: ${titleColor}; font-weight: 700;">${displayTitle}</h3>
                                ${summary.description ? `<p class="wikipedia-description" style="font-style: italic; color: ${descriptionColor}; font-size: 1.3em; margin-bottom: 25px; font-weight: 500; line-height: 1.4;">${summary.description}</p>` : ''}
                            </div>
                        </div>
                        <div style="margin-top: 25px;">
                            ${paragraphs.map(para => {
                                // Further split long paragraphs by single newlines for better readability
                                const sentences = para.split('\n').filter(s => s.trim().length > 0);
                                return sentences.map(sentence => 
                                    `<p style="margin-bottom: 18px; color: ${textColor}; text-align: justify;">${sentence.trim()}</p>`
                                ).join('');
                            }).join('')}
                        </div>
                        ${summary.url ? `
                            <div class="wikipedia-divider" style="margin-top: 35px; padding-top: 25px; border-top: 2px solid ${borderColor};">
                                <a href="${summary.url}" target="_blank" class="wikipedia-link"
                                   style="display: inline-block; padding: 14px 28px; background: #667eea; color: white; 
                                          text-decoration: none; border-radius: 6px; font-weight: bold; 
                                          transition: background 0.3s; font-size: 1.05em;">
                                    Read full article on Wikipedia ‚Üí
                                </a>
                            </div>
                        ` : ''}
                    </div>
                `;
                
            } catch (error) {
                wikipediaContentEl.innerHTML = `<div class="error">Error loading Wikipedia: ${error.message}</div>`;
            }
        }
        
    </script>
</body>
</html>
